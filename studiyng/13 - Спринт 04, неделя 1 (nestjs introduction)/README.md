# nestjs. Структура проекта

***
Проект на NestJS, организованный по функциональным особенностям (features), может иметь следующую структуру:

1. Features: Каждая функциональная особенность, такая как `users`, `orders`, `products`, находится в своей отдельной папке. Это позволяет легко находить и управлять кодом, связанным с конкретной областью функциональности.

2. В каждой папке функциональности (`users`, `orders` и т.д.) обычно находятся следующие подпапки:

* API: Содержит контроллеры, которые обрабатывают входящие HTTP-запросы, возвращают ответы клиенту и могут взаимодействовать с слоем приложения для выполнения бизнес-логики. input и view (output) модели

* Application: Этот слой отвечает за бизнес-логику. Здесь обычно находятся сервисы (use-cases), которые содержат основную логику приложения и правила, координируют действия и взаимодействие между различными компонентами в домене.

* Domain: Содержит основные сущности, интерфейсы, типы и классы, которые представляют и инкапсулируют бизнес-правила и данные. Это ядро вашего приложения, включающее в себя бизнес-модели и логику.

* Infrastructure: В этой папке располагаются элементы инфраструктуры, такие как модули для работы с базами данных (repositories), внешними сервисами и т.д. Этот слой обеспечивает взаимодействие вашего приложения с внешним миром и инструментами, необходимыми для его функционирования.

* Эта структура помогает организовать код таким образом, чтобы он был модульным, масштабируемым и легко поддерживаемым. Каждая часть приложения отделена, что позволяет упростить тестирование и разработку.

> Деление на features не единственный подход, это лишь один из вариантов организации структуры проекта

# Nestjs Основные особенности
***

## [request lifecycle (Жизненный цикл запроса)](https://docs.nestjs.com/faq/request-lifecycle):
* В NestJS каждый входящий запрос проходит через несколько этапов. Это включает маршрутизацию, выполнение middleware, guard, interceptor, и pipe.
* Цикл начинается с маршрутизации запроса к соответствующему контроллеру, затем запрос может быть модифицирован или отфильтрован на каждом этапе, прежде чем достигнет метода обработчика.


## [Middleware](https://docs.nestjs.com/middleware):
* Запрос сначала проходит через глобальные middleware (последовательно, как в express), если таковые определены (app.use).
* Затем он достигает модульного уровня, где может быть обработан модульными middleware.
* Сначала срабатывает middleware, определенный в корневом модуле, затем, срабатывают middleware в модулях в соответствии с порядком в массиве imports

> в nestjs классические middleware применяются довольно редко. Вместо этого рекомендуется применять другие этапы для обработки запроса.

## [Guards](https://docs.nestjs.com/guards)
* Guards используются для реализации аутентификации и авторизации.
- Они определяют, имеет ли пользователь доступ к определенным маршрутам или методам контроллера.
- Подобно middleware, guards могут быть глобальными и применяться ко всему приложению.
## [Interceptors](https://docs.nestjs.com/interceptors)
- Interceptors могут изменять входящие запросы и исходящие ответы.
- Они часто используются для добавления дополнительной логики, такой как трансформация результатов.
## [Pipes](https://docs.nestjs.com/interceptors)
- Pipes используются для трансформации и валидации входящих данных.
- Они могут автоматически преобразовывать входные данные в нужный формат или проверять на соответствие определенным критериям.
- Глобальные pipes применяются ко всем входящим данным в приложении.
## [Exception filters](https://docs.nestjs.com/exception-filters)
- Exception Filters используются для обработки исключений, возникающих во время выполнения приложения.
- Они позволяют централизованно обрабатывать ошибки и возвращать подходящие ответы клиентам.
- Глобальные exception filters обрабатывают исключения, возникающие на любом этапе обработки запроса в приложении.
## [Custom Decorators](https://docs.nestjs.com/custom-decorators)
- Custom Decorators позволяют расширять функциональность стандартных декораторов NestJS.
- Они могут использоваться для добавления дополнительной функциональности на любом уровне приложения, включая контроллеры и их методы.
- Можно объединять несколько декораторов в один.

> Отличительной особенностью nestjs является использование typescript decorators.
> * TypeScript декораторы - это специальный вид декларативного выражения, которое можно прикрепить к классу, методу, аксессору, свойству или параметру. Декораторы используют форму `@expression`, где `expression` должно вычисляться в функцию, которая будет вызвана во время выполнения программы с информацией о декорированном объявлении.
> * Декораторы предоставляют способ добавления аннотаций и метапрограммирования к вашему коду на уровне класса и его членов. Они являются частью предложения по декораторам для JavaScript, которое находится на стадии разработки, но уже доступно в TypeScript.
> 
> Вот основные виды декораторов в TypeScript:
> * Декораторы классов: Применяются непосредственно перед описанием класса. Декоратор класса получает конструктор класса в качестве его единственного аргумента.
> * Декораторы методов: Применяются к методам класса. Декоратор метода получает три аргумента: целевой объект, имя метода и дескриптор свойства метода.
> * Декораторы свойств: Применяются к свойствам класса. Декоратор свойства получает два аргумента: целевой объект и имя свойства.
> * Декораторы аксессоров: Применяются к аксессорам класса (геттерам и сеттерам). Аргументы аналогичны декораторам методов.
> * Декораторы параметров: Применяются к параметрам методов или конструкторов. Декоратор параметра получает три аргумента: целевой объект, имя метода и индекс параметра в массиве аргументов.
> 
> Также стоит упомянуть, что для корректной работы декораторов в TypeScript необходимо включить опцию компилятора `experimentalDecorators`. Это связано с тем, что декораторы в JavaScript все еще находятся на стадии предложения и не являются частью стандарта ECMAScript на данный момент.

## [Репозиторий с занятия](https://github.com/it-incubator/ed-back-lessons-nestjs.git)
Для данного занятия актуальная ветка `lesson-1`
